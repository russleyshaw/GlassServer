import axios from "axios";
import { average } from "./math";
import { buildMap } from "./map";
import { BoundingBox } from "./bbox";

function airportQuery(bbox: BoundingBox) {
    const bboxStr = `${bbox.bottom},${bbox.left},${bbox.top},${bbox.right}`;

    return `
/*
This has been generated by the overpass-turbo wizard.
The original search was:
“airport”
*/
[out:json][timeout:25];
// gather results
(
  // query part for: “airport”
  node["aeroway"="aerodrome"](${bboxStr});
  way["aeroway"="aerodrome"](${bboxStr});
  relation["aeroway"="aerodrome"](${bboxStr});
);
// print results
out body;
>;
out skel qt;
`;
}

enum Tags {
    ELEVATION = "ele",
    NAME = "name",
    AEROWAY = "aeroway",
}

interface OverpassNodeElement {
    type: "node";
    id: number;
    lat: number;
    lon: number;
    tags: Record<string, string>;
}

interface OverpassWayElement {
    type: "way";
    id: number;
    nodes: number[];
    tags?: Record<string, string>;
}

type OverpassElement = OverpassNodeElement | OverpassWayElement;

function isNodeElement(element: OverpassElement): element is OverpassNodeElement {
    return element.type === "node";
}

function isWayElement(element: OverpassElement): element is OverpassWayElement {
    return element.type === "way";
}

interface OverpassResponse {
    version: number;
    generator: string;
    elements: OverpassElement[];
}

export async function doOpenpassRequest(request: string): Promise<OverpassResponse> {
    const response = await axios({
        method: "post",
        url: "https://overpass-api.de/api/interpreter",
        data: request,
    });

    return response.data as OverpassResponse;
}

interface Airport {
    id: number;
    name: string;
    lat: number;
    lon: number;
}

export async function getAirports(bbox: BoundingBox): Promise<Airports[]> {
    const query = airportQuery(bbox);

    const response = await doOpenpassRequest(query);

    const nodes = buildMap(
        response.elements.filter(isNodeElement),
        e => e.id,
        e => e,
    );

    const ways = buildMap(
        response.elements.filter(isWayElement),
        e => e.id,
        e => e,
    );

    const airports: Airport[] = [];

    for (const way of ways.values()) {
        if (isElementAirport(way)) {
            const wayNodes = way.nodes.map(id => nodes.get(id)!);

            const [lat, lon] = getCenterOfNodes(wayNodes);

            airports.push({
                id: way.id,
                name: way.tags?.[Tags.NAME] ?? "Unknown",
                lat,
                lon,
            });
        }
    }

    for (const node of nodes.values()) {
        if (isElementAirport(node)) {
            airports.push({
                id: node.id,
                name: node.tags?.[Tags.NAME] ?? "Unknown",
                lat: node.lat,
                lon: node.lon,
            });
        }
    }

    return airports;
}

function isElementAirport(element: OverpassElement): boolean {
    return element.tags?.[Tags.AEROWAY] === "aerodrome";
}

function getCenterOfNodes(nodes: OverpassNodeElement[]): [number, number] {
    const lat = average(nodes.map(node => node.lat));
    const lon = average(nodes.map(node => node.lon));

    return [lat, lon];
}
